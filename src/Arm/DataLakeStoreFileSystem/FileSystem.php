<?php

/**
 * Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 *
 * PHP version: 5.5
 *
 * @category    Microsoft
 *
 * @author      Azure PHP SDK <azurephpsdk@microsoft.com>
 * @copyright   2016 Microsoft Corporation
 * @license     https://github.com/Azure/azure-sdk-for-php/blob/arm/LICENSE
 *
 * @link        https://github.com/Azure/azure-sdk-for-php/tree/arm
 *
 * @version     Release: 0.10.0_2016, API Version: 2015-10-01-preview
 */

namespace MicrosoftAzure\Arm\DataLakeStoreFileSystem;

use MicrosoftAzure\Common\Internal\Http\HttpClient;
use MicrosoftAzure\Common\Internal\Resources;
use MicrosoftAzure\Common\Internal\Utilities;
use MicrosoftAzure\Common\Internal\Validate;

/**
 * FileSystem for Creates an Azure Data Lake Store filesystem client.
 */
class FileSystem
{
    /**
     * The service client object for the operations.
     *
     * @var DataLakeStoreFileSystemManagementClient
     */
    private $_client;

    /**
     * Creates a new instance for FileSystem.
     *
     * @param DataLakeStoreFileSystemManagementClient, Service client for FileSystem
     */
    public function __construct($client)
    {
        $this->_client = $client;
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent
     * appends to the file. NOTE: Concurrent append and normal (serial) append
     * CANNOT be used interchangeably. Once a file has been appended to using
     * either append option, it can only be appended to using that append option.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $filePath The Data Lake Store path (starting with '/') of the
     * file to which to append using concurrent append.
     * @param object $streamContents The file contents to include when appending
     * to the file.
     * @param AppendModeType $appendMode Indicates the concurrent append call
     * should create the file if it doesn't exist or just open the existing file
     * for append. Possible values include: 'autocreate'
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function concurrentAppend($accountName, $filePath, $streamContents, array $appendMode, array $customHeaders = [])
    {
        $response = $this->concurrentAppendAsync($accountName, $filePath, $streamContents, $appendMode, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Appends to the specified file. This method supports multiple concurrent
     * appends to the file. NOTE: Concurrent append and normal (serial) append
     * CANNOT be used interchangeably. Once a file has been appended to using
     * either append option, it can only be appended to using that append option.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $filePath The Data Lake Store path (starting with '/') of the
     * file to which to append using concurrent append.
     * @param object $streamContents The file contents to include when appending
     * to the file.
     * @param AppendModeType $appendMode Indicates the concurrent append call
     * should create the file if it doesn't exist or just open the existing file
     * for append. Possible values include: 'autocreate'
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function concurrentAppendAsync($accountName, $filePath, $streamContents, array $appendMode, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($filePath == null) {
            Validate::notNullOrEmpty($filePath, '$filePath');
        }
        if ($streamContents == null) {
            Validate::notNullOrEmpty($streamContents, '$streamContents');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/WebHdfsExt/{filePath}';
        $statusCodes = [200];
        $method = 'POST';

        $path = strtr($path, ['{filePath}' => $filePath]);
        $queryParams = ['appendMode' => $appendMode, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($transferEncoding != null) {
            $headers['Transfer-Encoding'] = $transferEncoding;
        }
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $headers['Content-Type'] = 'application/octet-stream';
        $body = $this->_client->getDataSerializer()->serialize($streamContents);

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $path The Data Lake Store path (starting with '/') of the
     * file or directory for which to check access.
     * @param string $fsaction File system operation read/write/execute in string
     * form, matching regex pattern '[rwx-]{3}'
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function checkAccess($accountName, $path, $fsaction = null, array $customHeaders = [])
    {
        $response = $this->checkAccessAsync($accountName, $path, $fsaction, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Checks if the specified access is available at the given path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $path The Data Lake Store path (starting with '/') of the
     * file or directory for which to check access.
     * @param string $fsaction File system operation read/write/execute in string
     * form, matching regex pattern '[rwx-]{3}'
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function checkAccessAsync($accountName, $path, $fsaction = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($path == null) {
            Validate::notNullOrEmpty($path, '$path');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{path}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{path}' => $path]);
        $queryParams = ['fsaction' => $fsaction, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Creates a directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $path The Data Lake Store path (starting with '/') of the
     * directory to create.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'boolean' => 'false'
     * ];
     * </pre>
     */
    public function mkdirs($accountName, $path, array $customHeaders = [])
    {
        $response = $this->mkdirsAsync($accountName, $path, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Creates a directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $path The Data Lake Store path (starting with '/') of the
     * directory to create.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function mkdirsAsync($accountName, $path, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($path == null) {
            Validate::notNullOrEmpty($path, '$path');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{path}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{path}' => $path]);
        $queryParams = ['op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Concatenates the list of source files into the destination file, removing
     * all source files upon success.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $destinationPath The Data Lake Store path (starting with '/')
     * of the destination file resulting from the concatenation.
     * @param array (string) $sources A list of comma seperated Data Lake Store
     * paths (starting with '/') of the files to concatenate, in the order in
     * which they should be concatenated.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function concat($accountName, $destinationPath, array $sources, array $customHeaders = [])
    {
        $response = $this->concatAsync($accountName, $destinationPath, $sources, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Concatenates the list of source files into the destination file, removing
     * all source files upon success.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $destinationPath The Data Lake Store path (starting with '/')
     * of the destination file resulting from the concatenation.
     * @param array (string) $sources A list of comma seperated Data Lake Store
     * paths (starting with '/') of the files to concatenate, in the order in
     * which they should be concatenated.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function concatAsync($accountName, $destinationPath, array $sources, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($destinationPath == null) {
            Validate::notNullOrEmpty($destinationPath, '$destinationPath');
        }
        if ($sources == null) {
            Validate::notNullOrEmpty($sources, '$sources');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{destinationPath}';
        $statusCodes = [200];
        $method = 'POST';

        $path = strtr($path, ['{destinationPath}' => $destinationPath]);
        $queryParams = ['sources' => $sources.join(','), 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Concatenates the list of source files into the destination file, deleting
     * all source files upon success. This method accepts more source file paths
     * than the Concat method. This method and the parameters it accepts are
     * subject to change for usability in an upcoming version.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $msConcatDestinationPath The Data Lake Store path (starting
     * with '/') of the destination file resulting from the concatenation.
     * @param object $streamContents A list of Data Lake Store paths (starting
     * with '/') of the source files. Must be in the format: sources=<comma
     * separated list>
     * @param bool $deleteSourceDirectory Indicates that as an optimization
     * instead of deleting each individual source stream, delete the source
     * stream folder if all streams are in the same folder instead. This results
     * in a substantial performance improvement when the only streams in the
     * folder are part of the concatenation operation. WARNING: This includes the
     * deletion of any other files that are not source files. Only set this to
     * true when source files are the only files in the source directory.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function msConcat($accountName, $msConcatDestinationPath, $streamContents, $deleteSourceDirectory = null, array $customHeaders = [])
    {
        $response = $this->msConcatAsync($accountName, $msConcatDestinationPath, $streamContents, $deleteSourceDirectory, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Concatenates the list of source files into the destination file, deleting
     * all source files upon success. This method accepts more source file paths
     * than the Concat method. This method and the parameters it accepts are
     * subject to change for usability in an upcoming version.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $msConcatDestinationPath The Data Lake Store path (starting
     * with '/') of the destination file resulting from the concatenation.
     * @param object $streamContents A list of Data Lake Store paths (starting
     * with '/') of the source files. Must be in the format: sources=<comma
     * separated list>
     * @param bool $deleteSourceDirectory Indicates that as an optimization
     * instead of deleting each individual source stream, delete the source
     * stream folder if all streams are in the same folder instead. This results
     * in a substantial performance improvement when the only streams in the
     * folder are part of the concatenation operation. WARNING: This includes the
     * deletion of any other files that are not source files. Only set this to
     * true when source files are the only files in the source directory.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function msConcatAsync($accountName, $msConcatDestinationPath, $streamContents, $deleteSourceDirectory = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($msConcatDestinationPath == null) {
            Validate::notNullOrEmpty($msConcatDestinationPath, '$msConcatDestinationPath');
        }
        if ($streamContents == null) {
            Validate::notNullOrEmpty($streamContents, '$streamContents');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{msConcatDestinationPath}';
        $statusCodes = [200];
        $method = 'POST';

        $path = strtr($path, ['{msConcatDestinationPath}' => $msConcatDestinationPath]);
        $queryParams = ['deleteSourceDirectory' => $deleteSourceDirectory, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $headers['Content-Type'] = 'application/octet-stream';
        $body = $this->_client->getDataSerializer()->serialize($streamContents);

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Get the list of file status objects specified by the file path, with
     * optional pagination parameters
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $listFilePath The Data Lake Store path (starting with '/') of
     * the directory to list.
     * @param int $listSize Gets or sets the number of items to return. Optional.
     * @param string $listAfter Gets or sets the item or lexographical index after
     * which to begin returning results. For example, a file list of 'a','b','d'
     * and listAfter='b' will return 'd', and a listAfter='c' will also return
     * 'd'. Optional.
     * @param string $listBefore Gets or sets the item or lexographical index
     * before which to begin returning results. For example, a file list of
     * 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c'
     * will also return 'a','b'. Optional.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'FileStatuses' => [
     *       'FileStatus' => ''
     *    ]
     * ];
     * </pre>
     */
    public function listFileStatus($accountName, $listFilePath, $listSize = null, $listAfter = null, $listBefore = null, array $customHeaders = [])
    {
        $response = $this->listFileStatusAsync($accountName, $listFilePath, $listSize, $listAfter, $listBefore, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Get the list of file status objects specified by the file path, with
     * optional pagination parameters
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $listFilePath The Data Lake Store path (starting with '/') of
     * the directory to list.
     * @param int $listSize Gets or sets the number of items to return. Optional.
     * @param string $listAfter Gets or sets the item or lexographical index after
     * which to begin returning results. For example, a file list of 'a','b','d'
     * and listAfter='b' will return 'd', and a listAfter='c' will also return
     * 'd'. Optional.
     * @param string $listBefore Gets or sets the item or lexographical index
     * before which to begin returning results. For example, a file list of
     * 'a','b','d' and listBefore='d' will return 'a','b', and a listBefore='c'
     * will also return 'a','b'. Optional.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function listFileStatusAsync($accountName, $listFilePath, $listSize = null, $listAfter = null, $listBefore = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($listFilePath == null) {
            Validate::notNullOrEmpty($listFilePath, '$listFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{listFilePath}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{listFilePath}' => $listFilePath]);
        $queryParams = ['listSize' => $listSize, 'listAfter' => $listAfter, 'listBefore' => $listBefore, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Gets the file content summary object specified by the file path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $getContentSummaryFilePath The Data Lake Store path (starting
     * with '/') of the file for which to retrieve the summary.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'ContentSummary' => [
     *       'directoryCount' => '',
     *       'fileCount' => '',
     *       'length' => '',
     *       'spaceConsumed' => ''
     *    ]
     * ];
     * </pre>
     */
    public function getContentSummary($accountName, $getContentSummaryFilePath, array $customHeaders = [])
    {
        $response = $this->getContentSummaryAsync($accountName, $getContentSummaryFilePath, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Gets the file content summary object specified by the file path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $getContentSummaryFilePath The Data Lake Store path (starting
     * with '/') of the file for which to retrieve the summary.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function getContentSummaryAsync($accountName, $getContentSummaryFilePath, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($getContentSummaryFilePath == null) {
            Validate::notNullOrEmpty($getContentSummaryFilePath, '$getContentSummaryFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/va/{getContentSummaryFilePath}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{getContentSummaryFilePath}' => $getContentSummaryFilePath]);
        $queryParams = ['op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Get the file status object specified by the file path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $getFilePath The Data Lake Store path (starting with '/') of
     * the file or directory for which to retrieve the status.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'FileStatus' => [
     *       'accessTime' => '',
     *       'blockSize' => '',
     *       'childrenNum' => '',
     *       'group' => '',
     *       'length' => '',
     *       'modificationTime' => '',
     *       'owner' => '',
     *       'pathSuffix' => '',
     *       'permission' => '',
     *       'type' => 'FILE|DIRECTORY'
     *    ]
     * ];
     * </pre>
     */
    public function getFileStatus($accountName, $getFilePath, array $customHeaders = [])
    {
        $response = $this->getFileStatusAsync($accountName, $getFilePath, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Get the file status object specified by the file path.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $getFilePath The Data Lake Store path (starting with '/') of
     * the file or directory for which to retrieve the status.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function getFileStatusAsync($accountName, $getFilePath, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($getFilePath == null) {
            Validate::notNullOrEmpty($getFilePath, '$getFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{getFilePath}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{getFilePath}' => $getFilePath]);
        $queryParams = ['op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Appends to the specified file. This method does not support multiple
     * concurrent appends to the file. NOTE: Concurrent append and normal
     * (serial) append CANNOT be used interchangeably. Once a file has been
     * appended to using either append option, it can only be appended to using
     * that append option. Use the ConcurrentAppend option if you would like
     * support for concurrent appends.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to which to append.
     * @param object $streamContents The file contents to include when appending
     * to the file.
     * @param int $offset The optional offset in the stream to begin the append
     * operation. Default is to append at the end of the stream.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function append($accountName, $directFilePath, $streamContents, $offset = null, array $customHeaders = [])
    {
        $response = $this->appendAsync($accountName, $directFilePath, $streamContents, $offset, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Appends to the specified file. This method does not support multiple
     * concurrent appends to the file. NOTE: Concurrent append and normal
     * (serial) append CANNOT be used interchangeably. Once a file has been
     * appended to using either append option, it can only be appended to using
     * that append option. Use the ConcurrentAppend option if you would like
     * support for concurrent appends.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to which to append.
     * @param object $streamContents The file contents to include when appending
     * to the file.
     * @param int $offset The optional offset in the stream to begin the append
     * operation. Default is to append at the end of the stream.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function appendAsync($accountName, $directFilePath, $streamContents, $offset = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($directFilePath == null) {
            Validate::notNullOrEmpty($directFilePath, '$directFilePath');
        }
        if ($streamContents == null) {
            Validate::notNullOrEmpty($streamContents, '$streamContents');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{directFilePath}';
        $statusCodes = [200];
        $method = 'POST';

        $path = strtr($path, ['{directFilePath}' => $directFilePath]);
        $queryParams = ['offset' => $offset, 'op' => $op, 'append' => $append, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($transferEncoding != null) {
            $headers['Transfer-Encoding'] = $transferEncoding;
        }
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $headers['Content-Type'] = 'application/octet-stream';
        $body = $this->_client->getDataSerializer()->serialize($streamContents);

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to create.
     * @param object $streamContents The file contents to include when creating
     * the file. This parameter is optional, resulting in an empty file if not
     * specified.
     * @param bool $overwrite The indication of if the file should be overwritten.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status Created(201).<br>
     */
    public function create($accountName, $directFilePath, $streamContents = null, $overwrite = null, array $customHeaders = [])
    {
        $response = $this->createAsync($accountName, $directFilePath, $streamContents, $overwrite, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Creates a file with optionally specified content.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to create.
     * @param object $streamContents The file contents to include when creating
     * the file. This parameter is optional, resulting in an empty file if not
     * specified.
     * @param bool $overwrite The indication of if the file should be overwritten.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function createAsync($accountName, $directFilePath, $streamContents = null, $overwrite = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($directFilePath == null) {
            Validate::notNullOrEmpty($directFilePath, '$directFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{directFilePath}';
        $statusCodes = [201];
        $method = 'PUT';

        $path = strtr($path, ['{directFilePath}' => $directFilePath]);
        $queryParams = ['overwrite' => $overwrite, 'op' => $op, 'write' => $write, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($transferEncoding != null) {
            $headers['Transfer-Encoding'] = $transferEncoding;
        }
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $headers['Content-Type'] = 'application/octet-stream';
        $body = $this->_client->getDataSerializer()->serialize($streamContents);

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to open.
     * @param int $length
     * @param int $offset
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), object
     */
    public function open($accountName, $directFilePath, $length = null, $offset = null, array $customHeaders = [])
    {
        $response = $this->openAsync($accountName, $directFilePath, $length, $offset, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Opens and reads from the specified file.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $directFilePath The Data Lake Store path (starting with '/')
     * of the file to open.
     * @param int $length
     * @param int $offset
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function openAsync($accountName, $directFilePath, $length = null, $offset = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($directFilePath == null) {
            Validate::notNullOrEmpty($directFilePath, '$directFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{directFilePath}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{directFilePath}' => $directFilePath]);
        $queryParams = ['length' => $length, 'offset' => $offset, 'op' => $op, 'read' => $read, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Sets the Access Control List (ACL) for a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setAclFilePath The Data Lake Store path (starting with '/')
     * of the file or directory on which to set the ACL.
     * @param string $aclspec The ACL spec included in ACL creation operations in
     * the format '[default:]user|group|other::r|-w|-x|-'
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function setAcl($accountName, $setAclFilePath, $aclspec, array $customHeaders = [])
    {
        $response = $this->setAclAsync($accountName, $setAclFilePath, $aclspec, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Sets the Access Control List (ACL) for a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setAclFilePath The Data Lake Store path (starting with '/')
     * of the file or directory on which to set the ACL.
     * @param string $aclspec The ACL spec included in ACL creation operations in
     * the format '[default:]user|group|other::r|-w|-x|-'
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function setAclAsync($accountName, $setAclFilePath, $aclspec, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($setAclFilePath == null) {
            Validate::notNullOrEmpty($setAclFilePath, '$setAclFilePath');
        }
        if ($aclspec == null) {
            Validate::notNullOrEmpty($aclspec, '$aclspec');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{setAclFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{setAclFilePath}' => $setAclFilePath]);
        $queryParams = ['aclspec' => $aclspec, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Modifies existing Access Control List (ACL) entries on a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $modifyAclFilePath The Data Lake Store path (starting with
     * '/') of the file or directory with the ACL being modified.
     * @param string $aclspec The ACL specification included in ACL modification
     * operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function modifyAclEntries($accountName, $modifyAclFilePath, $aclspec, array $customHeaders = [])
    {
        $response = $this->modifyAclEntriesAsync($accountName, $modifyAclFilePath, $aclspec, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Modifies existing Access Control List (ACL) entries on a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $modifyAclFilePath The Data Lake Store path (starting with
     * '/') of the file or directory with the ACL being modified.
     * @param string $aclspec The ACL specification included in ACL modification
     * operations in the format '[default:]user|group|other::r|-w|-x|-'
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function modifyAclEntriesAsync($accountName, $modifyAclFilePath, $aclspec, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($modifyAclFilePath == null) {
            Validate::notNullOrEmpty($modifyAclFilePath, '$modifyAclFilePath');
        }
        if ($aclspec == null) {
            Validate::notNullOrEmpty($aclspec, '$aclspec');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{modifyAclFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{modifyAclFilePath}' => $modifyAclFilePath]);
        $queryParams = ['aclspec' => $aclspec, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Removes existing Access Control List (ACL) entries for a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $removeAclFilePath The Data Lake Store path (starting with
     * '/') of the file or directory with the ACL being removed.
     * @param string $aclspec The ACL spec included in ACL removal operations in
     * the format '[default:]user|group|other'
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function removeAclEntries($accountName, $removeAclFilePath, $aclspec, array $customHeaders = [])
    {
        $response = $this->removeAclEntriesAsync($accountName, $removeAclFilePath, $aclspec, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Removes existing Access Control List (ACL) entries for a file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $removeAclFilePath The Data Lake Store path (starting with
     * '/') of the file or directory with the ACL being removed.
     * @param string $aclspec The ACL spec included in ACL removal operations in
     * the format '[default:]user|group|other'
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function removeAclEntriesAsync($accountName, $removeAclFilePath, $aclspec, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($removeAclFilePath == null) {
            Validate::notNullOrEmpty($removeAclFilePath, '$removeAclFilePath');
        }
        if ($aclspec == null) {
            Validate::notNullOrEmpty($aclspec, '$aclspec');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{removeAclFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{removeAclFilePath}' => $removeAclFilePath]);
        $queryParams = ['aclspec' => $aclspec, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Gets Access Control List (ACL) entries for the specified file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $aclFilePath The Data Lake Store path (starting with '/') of
     * the file or directory for which to get the ACL.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'AclStatus' => [
     *       'entries' => '',
     *       'group' => '',
     *       'owner' => '',
     *       'stickyBit' => 'false'
     *    ]
     * ];
     * </pre>
     */
    public function getAclStatus($accountName, $aclFilePath, array $customHeaders = [])
    {
        $response = $this->getAclStatusAsync($accountName, $aclFilePath, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Gets Access Control List (ACL) entries for the specified file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $aclFilePath The Data Lake Store path (starting with '/') of
     * the file or directory for which to get the ACL.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function getAclStatusAsync($accountName, $aclFilePath, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($aclFilePath == null) {
            Validate::notNullOrEmpty($aclFilePath, '$aclFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{aclFilePath}';
        $statusCodes = [200];
        $method = 'GET';

        $path = strtr($path, ['{aclFilePath}' => $aclFilePath]);
        $queryParams = ['op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $filePath The Data Lake Store path (starting with '/') of the
     * file or directory to delete.
     * @param bool $recursive The optional switch indicating if the delete should
     * be recursive
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'boolean' => 'false'
     * ];
     * </pre>
     */
    public function delete($accountName, $filePath, $recursive = null, array $customHeaders = [])
    {
        $response = $this->deleteAsync($accountName, $filePath, $recursive, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Deletes the requested file or directory, optionally recursively.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $filePath The Data Lake Store path (starting with '/') of the
     * file or directory to delete.
     * @param bool $recursive The optional switch indicating if the delete should
     * be recursive
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function deleteAsync($accountName, $filePath, $recursive = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($filePath == null) {
            Validate::notNullOrEmpty($filePath, '$filePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{filePath}';
        $statusCodes = [200];
        $method = 'DELETE';

        $path = strtr($path, ['{filePath}' => $filePath]);
        $queryParams = ['recursive' => $recursive, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Rename a file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $renameFilePath The Data Lake Store path (starting with '/')
     * of the file or directory to move/rename.
     * @param string $destination The path to move/rename the file or folder to
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * When the resposne status is OK(200), 
     * <pre>
     * [
     *    'boolean' => 'false'
     * ];
     * </pre>
     */
    public function rename($accountName, $renameFilePath, $destination, array $customHeaders = [])
    {
        $response = $this->renameAsync($accountName, $renameFilePath, $destination, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Rename a file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $renameFilePath The Data Lake Store path (starting with '/')
     * of the file or directory to move/rename.
     * @param string $destination The path to move/rename the file or folder to
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function renameAsync($accountName, $renameFilePath, $destination, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($renameFilePath == null) {
            Validate::notNullOrEmpty($renameFilePath, '$renameFilePath');
        }
        if ($destination == null) {
            Validate::notNullOrEmpty($destination, '$destination');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{renameFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{renameFilePath}' => $renameFilePath]);
        $queryParams = ['destination' => $destination, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setOwnerFilePath The Data Lake Store path (starting with
     * '/') of the file or directory for which to set the owner.
     * @param string $owner The AAD Object ID of the user owner of the file or
     * directory. If empty, the property will remain unchanged.
     * @param string $group The AAD Object ID of the group owner of the file or
     * directory. If empty, the property will remain unchanged.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function setOwner($accountName, $setOwnerFilePath, $owner = null, $group = null, array $customHeaders = [])
    {
        $response = $this->setOwnerAsync($accountName, $setOwnerFilePath, $owner, $group, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Sets the owner of a file or directory.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setOwnerFilePath The Data Lake Store path (starting with
     * '/') of the file or directory for which to set the owner.
     * @param string $owner The AAD Object ID of the user owner of the file or
     * directory. If empty, the property will remain unchanged.
     * @param string $group The AAD Object ID of the group owner of the file or
     * directory. If empty, the property will remain unchanged.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function setOwnerAsync($accountName, $setOwnerFilePath, $owner = null, $group = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($setOwnerFilePath == null) {
            Validate::notNullOrEmpty($setOwnerFilePath, '$setOwnerFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{setOwnerFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{setOwnerFilePath}' => $setOwnerFilePath]);
        $queryParams = ['owner' => $owner, 'group' => $group, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setPermissionFilePath The Data Lake Store path (starting
     * with '/') of the file or directory for which to set the permission.
     * @param string $permission A string representation of the permission (i.e
     * 'rwx'). If empty, this property remains unchanged.
     * @param array $customHeaders An array of custom headers ['key' => 'value'] that will be added to
     *  the HTTP request.
     *
     * @return array
     * Empty array with resposne status OK(200).<br>
     */
    public function setPermission($accountName, $setPermissionFilePath, $permission = null, array $customHeaders = [])
    {
        $response = $this->setPermissionAsync($accountName, $setPermissionFilePath, $permission, $customHeaders);

        if ($response->getBody()) {
            $contents = $response->getBody()->getContents();
            if ($contents) {
                return $this->_client->getDataSerializer()->deserialize($contents);
            }
        }

        return [];
    }

    /**
     * Sets the permission of the file or folder.
     *
     * @param string $accountName The Azure Data Lake Store account to execute
     * filesystem operations on.
     * @param string $setPermissionFilePath The Data Lake Store path (starting
     * with '/') of the file or directory for which to set the permission.
     * @param string $permission A string representation of the permission (i.e
     * 'rwx'). If empty, this property remains unchanged.
     * @param array $customHeaders An array of custom headers ['key' => 'value']
     * that will be added to the HTTP request.
     *
     * @return \GuzzleHttp\Psr7\Response
     */
    public function setPermissionAsync($accountName, $setPermissionFilePath, $permission = null, array $customHeaders = [])
    {
        if ($accountName == null) {
            Validate::notNullOrEmpty($accountName, '$accountName');
        }
        if ($this->_client->getAdlsFileSystemDnsSuffix() == null) {
            Validate::notNullOrEmpty($this->_client->getAdlsFileSystemDnsSuffix(), '$this->_client->getAdlsFileSystemDnsSuffix()');
        }
        if ($setPermissionFilePath == null) {
            Validate::notNullOrEmpty($setPermissionFilePath, '$setPermissionFilePath');
        }
        if ($this->_client->getApiVersion() == null) {
            Validate::notNullOrEmpty($this->_client->getApiVersion(), '$this->_client->getApiVersion()');
        }

        $path = '/webhdfs/v1/{setPermissionFilePath}';
        $statusCodes = [200];
        $method = 'PUT';

        $path = strtr($path, ['{setPermissionFilePath}' => $setPermissionFilePath]);
        $queryParams = ['permission' => $permission, 'op' => $op, 'api-version' => $this->_client->getApiVersion()];
        $headers = $customHeaders;
        if ($this->_client->getAcceptLanguage() != null) {
            $headers['accept-language'] = $this->_client->getAcceptLanguage();
        }
        if ($this->_client->getGenerateClientRequestId()) {
            $headers[Resources::X_MS_REQUEST_ID] = Utilities::getGuid();
        }

        $body = '';

        $response = HttpClient::send(
            $method,
            $headers,
            $queryParams,
            [],
            $this->_client->getUrl($path),
            $statusCodes,
            $body,
            $this->_client->getFilters()
        );

        return $response;
    }
}
